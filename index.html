<!DOCTYPE html>
<html lang="pt-BR">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Multi-RSSI • Círculos com Zoom & Drag (Firebase RTDB)</title>
<style>
  :root{--bg:#0b1220;--panel:#0f172a;--text:#e5e7eb;--muted:#94a3b8;--accent:#38bdf8}
  body{margin:0;background:#0b1220;color:#e5e7eb;font:15px/1.5 system-ui,Segoe UI,Roboto,Arial}
  .wrap{max-width:1100px;margin:32px auto;padding:20px}
  .box{background:#0f172a;border:1px solid #1f2937;border-radius:14px;padding:16px}
  .row{display:grid;grid-template-columns:1.4fr 1fr 1fr auto auto;gap:10px;align-items:end}
  label{display:block;color:#94a3b8;margin-bottom:6px}
  input{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #1f2937;background:#0b1220;color:#e5e7eb}
  button{padding:10px 14px;border:0;border-radius:10px;background:#38bdf8;color:#05101b;font-weight:700;cursor:pointer}
  .meta{color:#94a3b8;margin-top:10px}
  .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;background:#0b1220;border:1px solid #1f2937;border-radius:999px}
  .led{width:10px;height:10px;border-radius:50%;background:#ef4444}
  .led.ok{background:#22c55e}
  canvas{width:100%;height:64vh;display:block;background:#0b1220;border:1px solid #1f2937;border-radius:14px;margin-top:12px;cursor:grab}
  canvas.dragging{cursor:grabbing}
  .legend{margin-top:8px;color:#94a3b8;font-size:13px}
  code{background:#0b1220;border:1px solid #1f2937;border-radius:6px;padding:0 6px}
  .list{margin-top:10px;display:flex;flex-wrap:wrap;gap:8px}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid #1f2937;background:#0b1220;font-size:13px}
  .dot{width:10px;height:10px;border-radius:50%}
</style>

<div class="wrap">
  <div class="box">
    <h2 style="margin:0 0 8px">Círculos por RSSI (múltiplas chaves) • Zoom & Drag • Firebase RTDB</h2>
    <div class="meta">
      Endpoint: <code id="endpointLabel">https://esp32ble-83c9a-default-rtdb.firebaseio.com/medicoes.json</code>
    </div>

    <div class="row" style="margin-top:12px">
      <div>
        <label>Endpoint RTDB (.json)</label>
        <input id="endpoint" value="https://esp32ble-83c9a-default-rtdb.firebaseio.com/medicoes.json">
      </div>
      <div>
        <label>Intervalo de polling (ms)</label>
        <input id="pollMs" type="number" value="1000" min="200">
      </div>
      <div>
        <label>Timeout inativo (ms)</label>
        <input id="staleMs" type="number" value="7000" min="1000">
      </div>
      <button id="btnStart">Iniciar</button>
      <button id="btnReset">Reset view</button>
    </div>

    <div class="meta" style="margin-top:8px">
      <span class="pill"><span class="led" id="led"></span><span id="st">Parado</span></span>
      • Duplo-clique: reset • Scroll: zoom no cursor • Arraste um círculo para reposicioná-lo
    </div>

    <canvas id="view" title="Scroll = zoom • Duplo-clique = reset"></canvas>

    <div class="legend">
      Mapeamento ajustado para <b>−40…−90 dBm</b> com correção de escala log (dBm → potência).  
      −40 dBm → raio maior • −90 dBm → raio menor. Payload esperado: <code>{"esp32s3_01":-48,"esp32s3_02":-43}</code>
    </div>

    <div class="list" id="chips"></div>
  </div>
</div>

<script>
  // ====== Config ======
  const DEFAULT_ENDPOINT = "https://esp32ble-83c9a-default-rtdb.firebaseio.com/medicoes.json";


  // ====== Intervalo de RSSI (dBm) — linear ======
const RSSI_NEAR  = -40;   // mais forte (maior círculo)
const RSSI_FAR   = -90;   // mais fraco (menor círculo)

// ====== Ganho global de tamanho (ajuste “o quanto” quer ampliar) ======
const SIZE_GAIN  = 1.35;  // 1.0 = sem ganho; 1.2~1.6 deixa mais visível

// ====== Mapeamento de RSSI → Raio (linear, em UNIDADES DO MUNDO) ======
const R_MIN_FRAC = 0.06;  // 6% do menor lado (baseline zoom=1)
const R_MAX_FRAC = 0.26;  // 26% do menor lado (baseline zoom=1)
const R_SMOOTH   = 0.15;  // suavização do raio (0..1)


  // ====== Cena (world) e view (canvas) ======
  const canvas = document.getElementById('view');
  const ctx    = canvas.getContext('2d');
  const stEl   = document.getElementById('st');
  const ledEl  = document.getElementById('led');
  const chips  = document.getElementById('chips');
  const btnStart = document.getElementById('btnStart');
  const btnReset = document.getElementById('btnReset');
  const endpointInp = document.getElementById('endpoint');
  const pollMsInp   = document.getElementById('pollMs');
  const staleMsInp  = document.getElementById('staleMs');

  document.getElementById('endpointLabel').textContent = DEFAULT_ENDPOINT;

  const world = { zoom: 1, minZoom: 0.3, maxZoom: 4, originX: 0, originY: 0 };

  // key -> { x,y, rssi, rTarget, rCurrent, color, lastTs }
  const circles = new Map();

  let polling = false;
  let pollTimer = null;
  let controller = null;

  function setStatus(text, ok=false){ stEl.textContent = text; ledEl.className = "led" + (ok ? " ok" : ""); }

  // ====== Canvas helpers ======
  function resizeCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  function screenToWorld(sx, sy){
    const cx = sx - canvas.clientWidth/2;
    const cy = sy - canvas.clientHeight/2;
    return { x: world.originX + cx/world.zoom, y: world.originY + cy/world.zoom };
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }


function mapRSSItoRadius(rssi){
  const minSideScreen = Math.min(canvas.clientWidth, canvas.clientHeight);
  const baseMin = R_MIN_FRAC * minSideScreen;
  const baseMax = R_MAX_FRAC * minSideScreen;

  // clamp em dBm para o range desejado
  const rr = clamp(rssi, RSSI_FAR, RSSI_NEAR);

  // mapeamento linear 0..1
  const t  = (rr - RSSI_FAR) / (RSSI_NEAR - RSSI_FAR);

  // raio linear + ganho global
  let r = baseMin + t * (baseMax - baseMin);
  r *= SIZE_GAIN;

  // (opcional) garantir limite superior após o ganho
  const rMaxGain = baseMax * SIZE_GAIN;
  r = clamp(r, baseMin, rMaxGain);

  return r; // em unidades do MUNDO → cresce/encolhe com o zoom
}

  function colorHSLA(seed){
    let h=0; for(let i=0;i<seed.length;i++) h=(h*31+seed.charCodeAt(i))>>>0;
    const hue = h%360;
    return `hsla(${hue},70%,55%,0.55)`; // semi-transparente
  }

  function placeNewCircle(key){
    const idx = circles.size;
    const spacing = 140; // mundo
    const cols = Math.max(1, Math.floor((canvas.clientWidth/world.zoom)/spacing));
    const row  = Math.floor(idx/cols);
    const col  = idx%cols;
    const startX = -(cols-1)*spacing*0.5;
    return { x: startX + col*spacing, y: -150 + row*spacing };
  }

  function ensureChip(key,color){
    const id="chip-"+key.replace(/[^a-z0-9_-]/gi,'_');
    if(document.getElementById(id)) return;
    const chip=document.createElement('div'); chip.className='chip'; chip.id=id;
    const d=document.createElement('span'); d.className='dot'; d.style.background=color;
    const t=document.createElement('span'); t.textContent=key;
    chip.appendChild(d); chip.appendChild(t); chips.appendChild(chip);
  }
  function removeChip(key){
    const id="chip-"+key.replace(/[^a-z0-9_-]/gi,'_');
    const el=document.getElementById(id); if(el&&el.parentNode) el.parentNode.removeChild(el);
  }

  // ====== Interação ======
  canvas.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const delta = -Math.sign(e.deltaY)*0.12;
    const oldZ = world.zoom, newZ = clamp(world.zoom*(1+delta), world.minZoom, world.maxZoom);
    if(newZ===oldZ) return;
    const rect = canvas.getBoundingClientRect();
    const mx=e.clientX-rect.left, my=e.clientY-rect.top;
    const before=screenToWorld(mx,my);
    world.zoom=newZ;
    const after=screenToWorld(mx,my);
    world.originX += (before.x - after.x);
    world.originY += (before.y - after.y);
  }, {passive:false});

  canvas.addEventListener('dblclick', ()=>{ world.zoom=1; world.originX=0; world.originY=0; });

  let dragging=null;
  canvas.addEventListener('mousedown',(e)=>{
    const rect=canvas.getBoundingClientRect();
    const p=screenToWorld(e.clientX-rect.left, e.clientY-rect.top);
    let pick=null, best=Infinity;
    for(const [key,c] of circles){
      const d2=(p.x-c.x)**2+(p.y-c.y)**2;
      if(d2<=c.rCurrent**2 && d2<best){ pick={key,c}; best=d2; }
    }
    if(pick){ dragging={key:pick.key, dx:p.x-pick.c.x, dy:p.y-pick.c.y}; canvas.classList.add('dragging');}
  });
  window.addEventListener('mousemove',(e)=>{
    if(!dragging) return;
    const rect=canvas.getBoundingClientRect();
    const p=screenToWorld(e.clientX-rect.left, e.clientY-rect.top);
    const c=circles.get(dragging.key); if(c){ c.x=p.x-dragging.dx; c.y=p.y-dragging.dy; }
  });
  window.addEventListener('mouseup', ()=>{ dragging=null; canvas.classList.remove('dragging'); });

  // ====== Render + limpeza ======
  function drawGrid(w,h){
    const step=100;
    const left  = world.originX - w/(2*world.zoom);
    const right = world.originX + w/(2*world.zoom);
    const top   = world.originY - h/(2*world.zoom);
    const bot   = world.originY + h/(2*world.zoom);
    const sx=Math.floor(left/step)*step, ex=Math.ceil(right/step)*step;
    const sy=Math.floor(top/step)*step,  ey=Math.ceil(bot/step)*step;

    ctx.lineWidth=1/world.zoom;
    ctx.strokeStyle="rgba(148,163,184,0.1)";
    ctx.beginPath();
    for(let x=sx;x<=ex;x+=step){ ctx.moveTo(x,top); ctx.lineTo(x,bot); }
    for(let y=sy;y<=ey;y+=step){ ctx.moveTo(left,y); ctx.lineTo(right,y); }
    ctx.stroke();
  }

  function render(){
    const w=canvas.clientWidth, h=canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // limpeza por inatividade
    const now = Date.now();
    const staleMs = Number(staleMsInp.value || 7000);
    const del=[];
    for(const [key,c] of circles){
      if(now - c.lastTs > staleMs){ del.push(key); }
    }
    for(const k of del){ circles.delete(k); removeChip(k); }

    ctx.save();
    ctx.translate(w/2, h/2);
    ctx.scale(world.zoom, world.zoom);
    ctx.translate(-world.originX, -world.originY);

    drawGrid(w,h);

    for(const [key,c] of circles){
      c.rCurrent += (c.rTarget - c.rCurrent)*R_SMOOTH;

      ctx.beginPath();
      ctx.arc(c.x, c.y, c.rCurrent, 0, Math.PI*2);
      ctx.fillStyle = c.color;        // semi-transparente
      ctx.fill();
      ctx.lineWidth = 2/world.zoom;   // borda em px
      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      ctx.stroke();

      ctx.fillStyle = "rgba(229,231,235,0.9)";
      ctx.font = `${14/world.zoom}px system-ui,Segoe UI,Roboto,Arial`;
      const label = `${key} • ${c.rssi} dBm`;
      ctx.fillText(label, c.x + 10/world.zoom, c.y - 10/world.zoom);
    }

    ctx.restore();
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

  // ====== Polling Firebase ======
  async function pollOnce(endpoint){
    if (controller) controller.abort();
    controller = new AbortController();
    const signal = controller.signal;

    try{
      const res = await fetch(endpoint, { method:'GET', headers:{'Accept':'application/json'}, signal });
      if(!res.ok){ throw new Error(`HTTP ${res.status}`); }
      const data = await res.json(); // { key: rssi, ... }
      const now = Date.now();

      if (data && typeof data === 'object'){
        for (const [key, value] of Object.entries(data)) {
          const rssi = Number(value);
          if (Number.isNaN(rssi)) continue;

          let c = circles.get(key);
          if (!c) {
            const pos = placeNewCircle(key);
            const color = colorHSLA(key);
            c = {
              x: pos.x, y: pos.y,
              rssi,
              rTarget: mapRSSItoRadius(rssi),
              rCurrent: 2,
              color,
              lastTs: now
            };
            circles.set(key, c);
            ensureChip(key, color);
          } else {
            c.rssi = rssi;
            c.rTarget = mapRSSItoRadius(rssi);
            c.lastTs = now;
          }
        }
      }

      setStatus(`OK • ${new Date().toLocaleTimeString()}`, true);
    }catch(err){
      if (err.name === 'AbortError') return;
      setStatus(`Erro: ${err.message}`, false);
    }finally{
      controller = null;
    }
  }

  function startPolling(){
    const endpoint = (endpointInp.value || DEFAULT_ENDPOINT).trim();
    const pollMs   = Math.max(200, Number(pollMsInp.value || 1000));

    if (polling) { stopPolling(); }

    setStatus("Conectando…", false);
    polling = true;

    pollOnce(endpoint);
    setStatus("Rodando (polling)", true);

    pollTimer = setInterval(()=> pollOnce(endpoint), pollMs);
  }

  function stopPolling(){
    polling = false;
    if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }
    if (controller) { controller.abort(); controller = null; }
    setStatus("Parado", false);
  }

  btnStart.addEventListener('click', ()=>{
    if (!polling) startPolling(); else stopPolling();
    btnStart.textContent = polling ? "Parar" : "Iniciar";
  });

  btnReset.addEventListener('click', ()=>{ world.zoom=1; world.originX=0; world.originY=0; });
</script>
</html>
