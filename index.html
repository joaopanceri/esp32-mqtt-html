<!DOCTYPE html>
<html lang="pt-BR">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Multi-RSSI • Círculos com Zoom & Drag (MQTT/WSS • EMQX)</title>
<style>
  :root{--bg:#0b1220;--panel:#0f172a;--text:#e5e7eb;--muted:#94a3b8;--accent:#38bdf8}
  body{margin:0;background:var(--bg);color:var(--text);font:15px/1.5 system-ui,Segoe UI,Roboto,Arial}
  .wrap{max-width:1100px;margin:32px auto;padding:20px}
  .box{background:var(--panel);border:1px solid #1f2937;border-radius:14px;padding:16px}
  .row{display:grid;grid-template-columns:1fr 1fr auto auto;gap:10px;align-items:end}
  label{display:block;color:var(--muted);margin-bottom:6px}
  input{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #1f2937;background:#0b1220;color:var(--text)}
  button{padding:10px 14px;border:0;border-radius:10px;background:var(--accent);color:#05101b;font-weight:700;cursor:pointer}
  .meta{color:var(--muted);margin-top:10px}
  .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;background:#0b1220;border:1px solid #1f2937;border-radius:999px}
  .led{width:10px;height:10px;border-radius:50%;background:#ef4444}
  .led.ok{background:#22c55e}
  canvas{width:100%;height:64vh;display:block;background:#0b1220;border:1px solid #1f2937;border-radius:14px;margin-top:12px;cursor:grab}
  canvas.dragging{cursor:grabbing}
  .legend{margin-top:8px;color:var(--muted);font-size:13px}
  code{background:#0b1220;border:1px solid #1f2937;border-radius:6px;padding:0 6px}
  .list{margin-top:10px;display:flex;flex-wrap:wrap;gap:8px}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid #1f2937;background:#0b1220;font-size:13px}
  .dot{width:10px;height:10px;border-radius:50%}
</style>

<div class="wrap">
  <div class="box">
    <h2 style="margin:0 0 8px">Círculos por RSSI (múltiplos tópicos) • Zoom no scroll & arrastar</h2>
    <div class="meta">
      Broker WSS: <code>wss://j6466600.ala.us-east-1.emqxsl.com:8084/mqtt</code> • Filtro: <code>esp32/beacons/+/rssi_avg</code>
    </div>

    <div class="row" style="margin-top:12px">
      <div>
        <label>Usuário (EMQX)</label>
        <input id="user" placeholder="ex.: esp32_card01" autocomplete="username">
      </div>
      <div>
        <label>Senha (EMQX)</label>
        <input id="pass" type="password" placeholder="••••••••" autocomplete="current-password">
      </div>
      <button id="btn">Conectar</button>
      <button id="btnReset">Reset view</button>
    </div>

    <div class="meta" style="margin-top:8px">
      <span class="pill"><span class="led" id="led"></span><span id="st">Desconectado</span></span>
      &nbsp;•&nbsp; Duplo-clique no canvas: reset de zoom • Scroll: zoom sob o cursor • Arraste um círculo para reposicioná-lo
      • <b>Inatividade &gt; 5s remove o círculo</b>
    </div>

    <canvas id="view" title="Scroll = zoom • Duplo-clique = reset"></canvas>

    <div class="legend">
      Raio: <code>-30 dBm → maior</code> • <code>-100 dBm → menor</code>. Payload pode ser número puro ou JSON com <code>rssi_avg</code>.
    </div>

    <div class="list" id="chips"></div>
  </div>
</div>

<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<script>
  // ====== MQTT / Tópicos ======
  const WS_URL       = "wss://j6466600.ala.us-east-1.emqxsl.com:8084/mqtt";
  const TOPIC_FILTER = "esp32/beacons/+/rssi_avg";
  const KEEPALIVE    = 60;

  // ====== Mapeamento de RSSI → Raio (em UNIDADES DO MUNDO, independentes do zoom) ======
  const RSSI_NEAR  = -30;
  const RSSI_FAR   = -100;
  const R_MIN_FRAC = 0.05;  // 5% do menor lado da tela (baseline zoom=1)
  const R_MAX_FRAC = 0.18;  // 18% do menor lado da tela (baseline zoom=1)
  const R_SMOOTH   = 0.15;  // suavização do raio (0..1)

  // ====== Inatividade ======
  const STALE_MS = 5000; // 5s sem mensagem -> remove

  // ====== Cena (world) e view (canvas) ======
  const canvas = document.getElementById('view');
  const ctx    = canvas.getContext('2d');
  const stEl   = document.getElementById('st');
  const ledEl  = document.getElementById('led');
  const chips  = document.getElementById('chips');
  const btn    = document.getElementById('btn');
  const btnReset = document.getElementById('btnReset');

  let client = null;

  const world = { zoom: 1, minZoom: 0.3, maxZoom: 4, originX: 0, originY: 0 };

  // círculos por tópico (raios em mundo)
  const circles = new Map(); // topic -> {x,y,rssi,rTarget,rCurrent,color,lastTs}

  function setStatus(text, ok=false){ stEl.textContent = text; ledEl.className = "led" + (ok ? " ok" : ""); }

  function resizeCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  function screenToWorld(sx, sy){
    const cx = sx - canvas.clientWidth/2;
    const cy = sy - canvas.clientHeight/2;
    return { x: world.originX + cx/world.zoom, y: world.originY + cy/world.zoom };
  }
  function worldToScreen(wx, wy){
    const cx = (wx - world.originX)*world.zoom;
    const cy = (wy - world.originY)*world.zoom;
    return { x: canvas.clientWidth/2 + cx, y: canvas.clientHeight/2 + cy };
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // *** CORRIGIDO: raio em mundo não depende do zoom.
  function mapRSSItoRadius(rssi){
    const minSideScreen = Math.min(canvas.clientWidth, canvas.clientHeight); // baseline zoom=1
    const rMin = R_MIN_FRAC * minSideScreen;  // mundo ~ pixels quando zoom=1
    const rMax = R_MAX_FRAC * minSideScreen;
    const rr = clamp(rssi, RSSI_FAR, RSSI_NEAR);
    const t  = (rr - RSSI_FAR) / (RSSI_NEAR - RSSI_FAR); // 0..1
    return rMin + t*(rMax - rMin); // UNIDADES DO MUNDO (constantes vs zoom)
  }

  function colorHSLA(seed){
    let h=0; for(let i=0;i<seed.length;i++) h=(h*31+seed.charCodeAt(i))>>>0;
    const hue = h%360;
    return `hsla(${hue},70%,55%,0.55)`; // semi-transparente
  }

  function placeNewCircle(topic){
    const idx = circles.size;
    const spacing = 140; // em mundo
    const cols = Math.max(1, Math.floor((canvas.clientWidth/world.zoom)/spacing));
    const row  = Math.floor(idx/cols);
    const col  = idx%cols;
    const startX = -(cols-1)*spacing*0.5;
    return { x: startX + col*spacing, y: -150 + row*spacing };
  }

  function ensureChip(topic,color){
    const id="chip-"+topic.replace(/[^a-z0-9_-]/gi,'_');
    if(document.getElementById(id)) return;
    const chip=document.createElement('div'); chip.className='chip'; chip.id=id;
    const d=document.createElement('span'); d.className='dot'; d.style.background=color;
    const t=document.createElement('span'); t.textContent=topic;
    chip.appendChild(d); chip.appendChild(t); chips.appendChild(chip);
  }
  function removeChip(topic){
    const id="chip-"+topic.replace(/[^a-z0-9_-]/gi,'_');
    const el=document.getElementById(id); if(el&&el.parentNode) el.parentNode.removeChild(el);
  }

  // zoom no scroll
  canvas.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const delta = -Math.sign(e.deltaY)*0.12;
    const oldZ = world.zoom, newZ = clamp(world.zoom*(1+delta), world.minZoom, world.maxZoom);
    if(newZ===oldZ) return;
    const rect = canvas.getBoundingClientRect();
    const mx=e.clientX-rect.left, my=e.clientY-rect.top;
    const before=screenToWorld(mx,my);
    world.zoom=newZ;
    const after=screenToWorld(mx,my);
    world.originX += (before.x - after.x);
    world.originY += (before.y - after.y);
  }, {passive:false});

  // reset view
  canvas.addEventListener('dblclick', ()=>{ world.zoom=1; world.originX=0; world.originY=0; });

  // drag de círculos
  let dragging=null;
  canvas.addEventListener('mousedown',(e)=>{
    const rect=canvas.getBoundingClientRect();
    const p=screenToWorld(e.clientX-rect.left, e.clientY-rect.top);
    let pick=null, best=Infinity;
    for(const [topic,c] of circles){
      const d2=(p.x-c.x)**2+(p.y-c.y)**2;
      if(d2<=c.rCurrent**2 && d2<best){ pick={topic,c}; best=d2; }
    }
    if(pick){ dragging={topic:pick.topic, dx:p.x-pick.c.x, dy:p.y-pick.c.y}; canvas.classList.add('dragging');}
  });
  window.addEventListener('mousemove',(e)=>{
    if(!dragging) return;
    const rect=canvas.getBoundingClientRect();
    const p=screenToWorld(e.clientX-rect.left, e.clientY-rect.top);
    const c=circles.get(dragging.topic); if(c){ c.x=p.x-dragging.dx; c.y=p.y-dragging.dy; }
  });
  window.addEventListener('mouseup', ()=>{ dragging=null; canvas.classList.remove('dragging'); });

  // render + limpeza
  function render(){
    const w=canvas.clientWidth, h=canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // remove inativos
    const now=Date.now(), del=[];
    for(const [topic,c] of circles){ if(now-c.lastTs>STALE_MS) del.push(topic); }
    for(const t of del){ circles.delete(t); removeChip(t); }

    ctx.save();
    ctx.translate(w/2, h/2);
    ctx.scale(world.zoom, world.zoom);
    ctx.translate(-world.originX, -world.originY);

    drawGrid(w,h);

    for(const [topic,c] of circles){
      c.rCurrent += (c.rTarget - c.rCurrent)*R_SMOOTH;

      ctx.beginPath();
      ctx.arc(c.x, c.y, c.rCurrent, 0, Math.PI*2); // raio em mundo → cresce com zoom
      ctx.fillStyle = c.color;        // semi-transparente
      ctx.fill();
      ctx.lineWidth = 2/world.zoom;   // borda constante em px de tela
      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      ctx.stroke();

      ctx.fillStyle = "rgba(229,231,235,0.9)";
      ctx.font = `${14/world.zoom}px system-ui,Segoe UI,Roboto,Arial`;
      const label = `${topic.split('/').slice(-3,-1).join('/')} • ${c.rssi} dBm`;
      ctx.fillText(label, c.x + 10/world.zoom, c.y - 10/world.zoom);
    }

    ctx.restore();
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

  function drawGrid(w,h){
    const step=100;
    const left=world.originX - w/(2*world.zoom);
    const right=world.originX + w/(2*world.zoom);
    const top=world.originY - h/(2*world.zoom);
    const bottom=world.originY + h/(2*world.zoom);
    const sx=Math.floor(left/step)*step, ex=Math.ceil(right/step)*step;
    const sy=Math.floor(top/step)*step,  ey=Math.ceil(bottom/step)*step;

    ctx.lineWidth=1/world.zoom;
    ctx.strokeStyle="rgba(148,163,184,0.1)";
    ctx.beginPath();
    for(let x=sx;x<=ex;x+=step){ ctx.moveTo(x,top); ctx.lineTo(x,bottom); }
    for(let y=sy;y<=ey;y+=step){ ctx.moveTo(left,y); ctx.lineTo(right,y); }
    ctx.stroke();
  }

  // MQTT
  function parsePayload(buf){
    let txt=new TextDecoder().decode(buf).trim();
    let num=Number(txt);
    if(!Number.isNaN(num)) return num;
    try{ const o=JSON.parse(txt); if(typeof o==='number') return o; if(typeof o.rssi_avg==='number') return o.rssi_avg; }catch(e){}
    return null;
  }
  function onMsg(topic, payload, packet){
    const rssi=parsePayload(payload); if(rssi==null) return;
    let c=circles.get(topic);
    if(!c){
      const color=colorHSLA(topic);
      const pos=placeNewCircle(topic);
      c={ x:pos.x, y:pos.y, rssi, rTarget:mapRSSItoRadius(rssi), rCurrent:2, color, lastTs:Date.now() };
      circles.set(topic,c); ensureChip(topic,color);
    }else{
      c.rssi=rssi; c.lastTs=Date.now(); c.rTarget=mapRSSItoRadius(rssi);
    }
  }
  function connect(){
    const username=document.getElementById('user').value.trim();
    const password=document.getElementById('pass').value;
    if(!username||!password){ alert("Informe usuário e senha do EMQX."); return; }
    if(client){ try{client.end(true);}catch(e){} client=null; }
    setStatus("Conectando…",false);
    client=mqtt.connect(WS_URL,{username,password,clean:true,keepalive:KEEPALIVE,reconnectPeriod:2000,connectTimeout:20000,clientId:'web-'+Math.random().toString(16).slice(2),protocolVersion:4});
    client.on('connect',()=>{ setStatus("Conectado",true); client.subscribe(TOPIC_FILTER,{qos:0},(err,g)=>{ setStatus(err?"Falha ao assinar":"Assinado: "+g.map(x=>x.topic).join(', '), !err); }); });
    client.on('reconnect',()=>setStatus("Reconectando…",false));
    client.on('close',()=>setStatus("Desconectado",false));
    client.on('error',e=>setStatus("Erro: "+(e?.message||e),false));
    client.on('message', onMsg);
  }
  document.getElementById('btn').addEventListener('click', connect);
  btnReset.addEventListener('click', ()=>{ world.zoom=1; world.originX=0; world.originY=0; });
</script>
</html>
